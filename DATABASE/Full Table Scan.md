지난주에, View 테이블을 생성할 일이 있었다.
전제 데이터를 사용자에게 보여주기가 위험하여, deleted 라는 칼럼을 추가하여, 해당 칼럼에 'Y'가 아닌 경우,row 데이터를 보여주도록 조건을 건 view 가상테이블을 만들었다.  

예를 들어, **TBL_USER** 이 있다고 하자.   
칼럼은 **email, name**가 있다. 기존 TBL_USER 은 이미 100개의 row 가 있다.   
필요없는 row 가 있고, 이 row 들을 모두 보여주면 안 되는 상황이 있다. 물론 TBL_USER를 모두 보여주면 안 되는 중요한 사안이 있을 듯 하진 않다.

어쨌든, 전체 100개 row 중, 50개 row에 대한 데이터는 정확한 데이터이다. 
그래서 **deleted**라는 칼럼을 추가하여, 삭제할 row, 삭제하지 않을 row를 구분하였다.(row 데이터를 직접 삭제하는 것은 위험한 걸로 알고 있다.)   
50개 row의 정합성을 확인해보니, 정확한 row는 총 30개, 삭제해야할 데이터는 20개였다. 그래서 deleted 가 'Y'인 20개 row만 업데이트 하였다. 30개 row 는 deleted가 'N'이지만, 수동으로해야하기에... 건너 뛰었다. 이걸 수기로 모두 'N'을 넣으면, 이건 개발자인지, 노가다꾼인지.. 모르니까.. 쿼리문으로 해결하기로 했다.

그래서 조건을 걸려고 1차적으로 쿼리문을 만들었는데,

> CREATE VIEW VIEW_TBL_USER AS SELECT email from where deleted not in('Y')

그런데 이렇게 작업하니, row 가 하나도 나오지 않는 것 이다.
좀 더 찾아보니, 조건을 하나 더 추가했어야 했다. 
> CREATE VIEW VIEW_TBL_USER AS SELECT email from deleted not in ('Y') or deleted is not null

오 이제 동작하는군. 하고 view 테이블을 만들어뒀는데...
이 View 가상테이블을 사수님이 보고, 추가적으로 피드백을 주셨다.
### 서현님, 이 view 테이블은 **full scan**을 타요. 그러니 **index** 를 만들어야 합니다.
지난번에 잠깐 사수님이 설명해주셨는데, 대충 넘긴 나의 죄다. 그래서 오늘은 공부하기로 했다.

> ## DATABASE 순차접근 (Full Table Scan)
> - : 데이터베이스의 한 릴레이션에서 데이터를 찾거나 재배열하기 위해 **데이터가 저장된 목록 중의 모든 데이터 요소를 차례 차례 조사하여 원하는 것을 찾아내는 것**
>- 튜플의 수가 많아지면, 검색 시간이 매우 오래걸린다는 단점이 있다.
>- full scan의 단점을 보완하기 위해 **인덱스** 가 등장
